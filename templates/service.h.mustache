/**
 * Autogenerated by Thrift Compiler (0.23.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef {{service.name}}_H
#define {{service.name}}_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "{{program.name}}_types.h"

{{#program.includes}}
#include "{{name}}_types.h"
{{/program.includes}}

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

// Forward declarations for argument/result helper structs
{{#service.function_helpers}}
{{#has_fields}}
class {{name}};
{{/has_fields}}
{{/service.function_helpers}}

// Argument and result helper structs
{{#service.function_helpers}}
{{#has_fields}}
class {{name}} {
 public:

  {{name}}() {
  }

  virtual ~{{name}}() noexcept;

{{#fields}}
  {{{cpp_type}}} {{name}};
{{/fields}}

{{#fields}}
  void __set_{{name}}(const {{{cpp_type}}}& val);
{{/fields}}

  bool operator == (const {{name}} & rhs) const
  {
    if (!({{equality_comparison}}))
      return false;
    return true;
  }
  bool operator != (const {{name}} &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const {{name}} & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

{{/has_fields}}
{{/service.function_helpers}}

class {{service.name}}If{{#service.has_extends}} : virtual public {{service.extends_name}}If{{/service.has_extends}} {
 public:
  virtual ~{{service.name}}If() {}
{{#service.functions}}
  virtual {{{cpp_return_signature}}} {{name}}({{{cpp_arguments_signature}}}) = 0;
{{/service.functions}}
};

class {{service.name}}IfFactory {
 public:
  typedef {{service.name}}If Handler;

  virtual ~{{service.name}}IfFactory() {}

  virtual {{service.name}}If* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler({{service.name}}If* /* handler */) = 0;
  };

class {{service.name}}IfSingletonFactory : virtual public {{service.name}}IfFactory {
 public:
  {{service.name}}IfSingletonFactory(const ::std::shared_ptr<{{service.name}}If>& iface) : iface_(iface) {}
  virtual ~{{service.name}}IfSingletonFactory() {}

  virtual {{service.name}}If* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler({{service.name}}If* /* handler */) override {}

 protected:
  ::std::shared_ptr<{{service.name}}If> iface_;
};

class {{service.name}}Null : virtual public {{service.name}}If{{#service.has_extends}} , virtual public {{service.extends_name}}Null{{/service.has_extends}} {
 public:
  virtual ~{{service.name}}Null() {}
{{#service.functions}}
{{#returns_void}}  void {{name}}({{{cpp_arguments_signature}}}) override {
    return;
  }{{/returns_void}}{{^returns_void}}{{#is_complex_return}}  void {{name}}({{{cpp_arguments_signature}}}) override {
    return;
  }{{/is_complex_return}}{{^is_complex_return}}  {{{return_cpp_type}}} {{name}}({{{cpp_arguments_signature}}}) override {
    {{{return_cpp_type}}} _return = {{{return_cpp_type}}}();
    return _return;
  }{{/is_complex_return}}{{/returns_void}}
{{/service.functions}}
};

// TODO: Add argument/result helper structs for each function here

class {{service.name}}Client : virtual public {{service.name}}If {
 public:
  {{service.name}}Client(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  {{service.name}}Client(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
{{#service.functions}}
  {{{cpp_return_signature}}} {{name}}({{{cpp_arguments_signature}}}) override;
  void send_{{name}}({{{arguments_signature}}});
{{#returns_void}}  void recv_{{name}}();{{/returns_void}}{{^returns_void}}{{#is_complex_return}}  void recv_{{name}}({{{return_cpp_type}}}& _return);{{/is_complex_return}}{{^is_complex_return}}  {{{return_cpp_type}}} recv_{{name}}();{{/is_complex_return}}{{/returns_void}}
{{/service.functions}}
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class {{service.name}}Processor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<{{service.name}}If> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void ({{service.name}}Processor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
{{#service.functions}}
  void process_{{name}}(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
{{/service.functions}}
 public:
  {{service.name}}Processor(::std::shared_ptr<{{service.name}}If> iface) :
    iface_(iface) {
{{#service.functions}}
    processMap_["{{name}}"] = &{{service.name}}Processor::process_{{name}};
{{/service.functions}}
  }

  virtual ~{{service.name}}Processor() {}
};

class {{service.name}}ProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  {{service.name}}ProcessorFactory(const ::std::shared_ptr< {{service.name}}IfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< {{service.name}}IfFactory > handlerFactory_;
};

class {{service.name}}Multiface : virtual public {{service.name}}If{{#service.has_extends}}, public {{service.extends_name}}Multiface{{/service.has_extends}} {
 public:
  {{service.name}}Multiface(std::vector<std::shared_ptr<{{service.name}}If> >& ifaces) : ifaces_(ifaces) {
{{#service.has_extends}}
    std::vector<std::shared_ptr<{{service.extends_name}}If> > supers;
    for (std::shared_ptr<{{service.name}}If> iface : ifaces) {
      supers.push_back(iface);
    }
    {{service.extends_name}}Multiface::setIfaces(supers);
{{/service.has_extends}}
  }
  virtual ~{{service.name}}Multiface() {}
 protected:
  std::vector<std::shared_ptr<{{service.name}}If> > ifaces_;
  {{service.name}}Multiface() {}
  void setIfaces(std::vector<std::shared_ptr<{{service.name}}If> >& ifaces) { ifaces_ = ifaces; }
 public:
{{#service.functions}}
{{#returns_void}}  void {{name}}({{{cpp_arguments_signature}}}) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->{{name}}({{arguments_list}});
    }
    ifaces_[i]->{{name}}({{arguments_list}});
  }{{/returns_void}}{{^returns_void}}{{#is_complex_return}}  void {{name}}({{{cpp_arguments_signature}}}) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->{{name}}({{arguments_list}});
    }
    ifaces_[i]->{{name}}({{arguments_list}});
  }{{/is_complex_return}}{{^is_complex_return}}  {{{return_cpp_type}}} {{name}}({{{cpp_arguments_signature}}}) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->{{name}}({{arguments_list}});
    }
    return ifaces_[i]->{{name}}({{arguments_list}});
  }{{/is_complex_return}}{{/returns_void}}
{{/service.functions}}

};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

#endif