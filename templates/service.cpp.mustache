/**
 * Autogenerated by Thrift Compiler (0.23.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "{{service.name}}.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

// Implementation of argument/result helper structs
{{#service.function_helpers}}
{{#has_fields}}

{{name}}::~{{name}}() noexcept {
}

{{#fields}}
void {{struct_name}}::__set_{{name}}(const {{{cpp_type}}}{{#is_complex_type}}&{{/is_complex_type}} val) {
  this->{{name}} = val;
}
{{/fields}}

bool {{name}}::operator < (const {{name}} & other) const {
{{#fields}}
  if (!({{name}} < other.{{name}})) {
    if (other.{{name}} < {{name}}) return false;
  } else return true;
{{/fields}}
  return false;
}

void {{name}}::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "{{name}}(";
{{#fields}}
  out << "{{name}}=" << to_string({{name}});{{^last}} << ", ";{{/last}}
{{/fields}}
  out << ")";
}

uint32_t {{name}}::read(::apache::thrift::protocol::TProtocol* iprot) {
  // TODO: Implement proper read method
  return 0;
}

uint32_t {{name}}::write(::apache::thrift::protocol::TProtocol* oprot) const {
  // TODO: Implement proper write method
  return 0;
}

{{/has_fields}}
{{/service.function_helpers}}

// Implementation of {{service.name}}Client

{{#service.functions}}
{{{cpp_return_signature}}} {{service.name}}Client::{{name}}({{{cpp_arguments_signature}}}) {
{{^is_oneway}}
  send_{{name}}({{arguments_list}});
{{#returns_void}}
  recv_{{name}}();
{{/returns_void}}
{{^returns_void}}
{{#is_complex_return}}
  recv_{{name}}(_return);
{{/is_complex_return}}
{{^is_complex_return}}
  return recv_{{name}}();
{{/is_complex_return}}
{{/returns_void}}
{{/is_oneway}}
{{#is_oneway}}
  send_{{name}}({{arguments_list}});
{{/is_oneway}}
}

void {{service.name}}Client::send_{{name}}({{{arguments_signature}}}) {
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("{{name}}", ::apache::thrift::protocol::{{#is_oneway}}T_ONEWAY{{/is_oneway}}{{^is_oneway}}T_CALL{{/is_oneway}}, cseqid);

  {{service.name}}_{{name}}_pargs args;
{{#arguments}}
  args.{{name}} = &{{name}};
{{/arguments}}
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

{{^is_oneway}}
{{#returns_void}}
void {{service.name}}Client::recv_{{name}}() {

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("{{name}}") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  {{service.name}}_{{name}}_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();

{{#exceptions}}
  if (result.__isset.{{name}}) {
    throw result.{{name}};
  }
{{/exceptions}}
  return;
}
{{/returns_void}}
{{^returns_void}}
{{#is_complex_return}}
void {{service.name}}Client::recv_{{name}}({{{return_cpp_type}}}& _return) {
{{/is_complex_return}}
{{^is_complex_return}}
{{{return_cpp_type}}} {{service.name}}Client::recv_{{name}}() {
{{/is_complex_return}}

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("{{name}}") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  {{service.name}}_{{name}}_presult result;
{{#is_complex_return}}
  result.success = &_return;
{{/is_complex_return}}
  result.read(iprot_);
  iprot_->readMessageEnd();

  if (result.__isset.success) {
{{^is_complex_return}}
    return result.success;
{{/is_complex_return}}
{{#is_complex_return}}
    return;
{{/is_complex_return}}
  }
{{#exceptions}}
  if (result.__isset.{{name}}) {
    throw result.{{name}};
  }
{{/exceptions}}
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "{{name}} failed: unknown result");
}
{{/returns_void}}
{{/is_oneway}}

{{/service.functions}}

// Implementation of {{service.name}}Processor

bool {{service.name}}Processor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
{{#service.has_extends}}
    return {{service.extends_name}}Processor::dispatchCall(iprot, oprot, fname, seqid, callContext);
{{/service.has_extends}}
{{^service.has_extends}}
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
{{/service.has_extends}}
  } else {
    (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  }
  return true;
}

{{#service.functions}}
void {{service.name}}Processor::process_{{name}}(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext) {
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("{{service.name}}.{{name}}", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "{{service.name}}.{{name}}");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "{{service.name}}.{{name}}");
  }

  {{service.name}}_{{name}}_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "{{service.name}}.{{name}}", bytes);
  }

  {{service.name}}_{{name}}_result result;

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "{{service.name}}.{{name}}");
  }

{{^is_oneway}}
  try {
{{#returns_void}}
    iface_->{{name}}({{arguments_list}});
{{/returns_void}}
{{^returns_void}}
{{#is_complex_return}}
    iface_->{{name}}(result.success{{#arguments}}, args.{{name}}{{/arguments}});
    result.__isset.success = true;
{{/is_complex_return}}
{{^is_complex_return}}
    result.success = iface_->{{name}}({{arguments_list}});
    result.__isset.success = true;
{{/is_complex_return}}
{{/returns_void}}
{{#exceptions}}
  } catch ({{type}}& {{name}}) {
    result.{{name}} = {{name}};
    result.__isset.{{name}} = true;
{{/exceptions}}
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "{{service.name}}.{{name}}");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("{{name}}", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  oprot->writeMessageBegin("{{name}}", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "{{service.name}}.{{name}}", bytes);
  }
{{/is_oneway}}
{{#is_oneway}}
  try {
    iface_->{{name}}({{arguments_list}});
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "{{service.name}}.{{name}}");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "{{service.name}}.{{name}}", 0);
  }
{{/is_oneway}}
}

{{/service.functions}}

::std::shared_ptr< ::apache::thrift::TProcessor > {{service.name}}ProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::std::shared_ptr< {{service.name}}If > handler(handlerFactory_->getHandler(connInfo), [&]({{service.name}}If* h) { handlerFactory_->releaseHandler(h); });
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new {{service.name}}Processor(handler));
  return processor;
}